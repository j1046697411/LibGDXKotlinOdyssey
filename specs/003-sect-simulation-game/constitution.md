# 宗门模拟游戏 - 项目章程 (Constitution)

**项目**: 宗门模拟游戏 | **版本**: 1.0.0 | **日期**: 2025-12-13  
**目的**: 建立项目开发、代码质量、测试、用户体验和性能的核心原则

---

## 1. 核心原则

### 1.1 卓越代码质量

#### 原则
所有代码必须遵循 Kotlin 最佳实践，具有清晰的意图、适当的注释和一致的风格。

#### 规则

- **代码风格与格式**
  - [ ] 遵循官方 Kotlin 编码规范 (https://kotlinlang.org/docs/coding-conventions.html)
  - [ ] 使用 ktlint 进行自动格式检查 (集成到 CI/CD)
  - [ ] 最大行长: 120 字符
  - [ ] 使用 4 空格缩进
  - [ ] 导入排序: java.* → javax.* → 外部库 → 项目内部

- **命名与可读性**
  - [ ] 类名: PascalCase (例: `SectSystem`, `FacilityBuilder`)
  - [ ] 函数名: camelCase (例: `validateConstruction`, `updateResources`)
  - [ ] 常量名: UPPER_SNAKE_CASE (例: `DEFAULT_MAX_DISCIPLES`)
  - [ ] 私有成员前缀: `_` (例: `_internalCache`)
  - [ ] 避免单字母变量名 (除了循环计数器 i, j, k)
  - [ ] 布尔值变量应以 is/has/can 开头

- **注释与文档**
  - [ ] 所有 public API 必须有 KDoc 注释
  - [ ] KDoc 格式: 简短描述、详细描述、参数、返回值、异常
  - [ ] 复杂逻辑必须有内联注释解释意图
  - [ ] TODO/FIXME 注释必须包含作者名称和 issue 编号

- **模块化与依赖**
  - [ ] 每个模块通过 ECS Addon 系统实现，避免循环依赖
  - [ ] Addon 之间通过组件消息通信，不直接调用
  - [ ] 最大深度: 3 层 (API → Business Logic → ECS Core)
  - [ ] 每个文件不超过 500 行代码

- **错误处理**
  - [ ] 使用 `Result<T>` 类型处理可预见的错误
  - [ ] 使用异常处理不可恢复的错误
  - [ ] 永远不要忽略异常 (catch 块必须有有意义的处理或重新抛出)
  - [ ] 自定义异常需要继承项目基类 `SectException`

#### 检查清单
- [ ] 代码通过 ktlint 检查
- [ ] 所有 public 方法有 KDoc 注释
- [ ] 没有 TODO 未追踪
- [ ] 最大环复杂度 ≤ 10
- [ ] 代码审查通过 (至少 1 个 reviewer)

---

### 1.2 严格测试标准

#### 原则
所有功能必须有对应的自动化测试，确保代码质量、可维护性和回归预防。

#### 规则

- **测试覆盖率**
  - [ ] 核心业务逻辑: ≥ 90% 覆盖率
  - [ ] 系统集成: ≥ 80% 覆盖率
  - [ ] UI 组件: ≥ 60% 覆盖率
  - [ ] 使用 JaCoCo 生成覆盖率报告，集成到 CI/CD

- **单元测试**
  - [ ] 使用 JUnit 5 + MockK 框架
  - [ ] 测试命名: `test[Function]When[Condition]Expect[Result]`
    - 例: `testValidateConstructionWhenInsufficientFundsExpectFailure`
  - [ ] 每个测试方法只测试一个行为
  - [ ] AAA 模式: Arrange → Act → Assert
  - [ ] 快速运行: 单个测试 < 100ms，套件 < 5s

- **集成测试**
  - [ ] 测试多个系统/模块协作
  - [ ] 使用真实的 ECS World 实例 (不 mock)
  - [ ] 每个用户故事至少有 1 个集成测试
  - [ ] 集成测试命名前缀: `IntegrationTest` 或放在 `integrationTest` 源集

- **性能测试**
  - [ ] 关键路径需要性能基准 (Benchmark)
  - [ ] 监测指标: 响应时间、内存占用、GC 暂停
  - [ ] 基准失败阈值: 性能下降 > 10%

- **测试数据与 Fixtures**
  - [ ] 使用 builder 模式构造测试数据
  - [ ] 提供 fixture 工厂类简化测试准备
  - [ ] 避免共享全局状态 (每个测试独立)

#### 检查清单
- [ ] 覆盖率报告生成并上传
- [ ] 所有新代码有对应测试
- [ ] 没有被跳过的测试 (@Ignore)
- [ ] 测试通过 CI/CD (必须项，否则阻止合并)
- [ ] 性能基准通过（关键系统）

---

### 1.3 用户体验一致性

#### 原则
纯文字描述界面必须提供一致、直观、可预测的交互模式，确保玩家快速学习和享受。

#### 规则

- **界面设计规范**
  - [ ] 所有屏幕遵循统一的信息架构 (标题 → 描述 → 操作)
  - [ ] 提示文案简洁明确，避免歧义
  - [ ] 命令/选项用 `[1]`, `[2]` 方括号标注
  - [ ] 状态显示: 用 ✓/✗/⚠ 图标表示成功/失败/警告
  - [ ] 数值显示统一格式 (例: `资源: 100/500 [木材] (+10/tick)`)

- **交互流程**
  - [ ] 所有操作可取消或返回 (提供 `[0] 返回` 或 `[q] 退出`)
  - [ ] 确认对话用一致的问法 (例: `确认该操作? (y/n)`)
  - [ ] 错误消息清晰指出原因和解决方案
  - [ ] 成功消息简洁确认 (例: `✓ 宗门已建设`)

- **信息层级**
  - [ ] 主屏幕: 宗门状态、弟子列表、任务列表
  - [ ] 详情页: 单个实体的完整信息
  - [ ] 输入页: 分步引导（如: 建设设施 → 选择类型 → 确认）
  - [ ] 列表分页: 每页 ≤ 10 项，提供翻页选项

- **键盘导航**
  - [ ] 支持数字键快速选择 (1-9, 0)
  - [ ] 支持字母快捷键 (s=save, q=quit, h=help)
  - [ ] 回车/空格确认默认选项
  - [ ] Tab 键导航下一项（如果支持）

- **国际化与本地化**
  - [ ] 所有文案集中在资源文件中，不硬编码
  - [ ] 支持 UTF-8 字符 (中文、符号)
  - [ ] 日期/数字格式遵循本地化规则

#### 检查清单
- [ ] UI 文案通过一致性审查
- [ ] 所有交互流程测试通过
- [ ] 错误消息清晰且可操作
- [ ] 支持预期的快捷键
- [ ] 无孤立或未关联的界面

---

### 1.4 高性能要求

#### 原则
游戏必须流畅运行，在 50+ 弟子、多个系统并行执行的场景下保持高帧率和低延迟。

#### 规则

- **性能目标**
  - [ ] 主循环帧率: ≥ 60 FPS (16.7ms/frame)
  - [ ] 单个系统 update: ≤ 5ms
  - [ ] 查询响应时间: ≤ 1ms (对于常见查询)
  - [ ] 内存占用: ≤ 500MB (启动后稳定)
  - [ ] GC 暂停: ≤ 10ms，频率 ≤ 1/s

- **ECS 优化**
  - [ ] 使用 ArchetypeService 按组件组合分组存储
  - [ ] 系统仅查询必需的组件组合 (避免过宽查询)
  - [ ] 批量操作优于逐个操作 (bulk update > loop update)
  - [ ] 缓存频繁查询结果 (如: 特定组件组合的实体列表)
  - [ ] 避免在 hot-path 中创建临时对象

- **资源管理**
  - [ ] 对象池化: 频繁创建/销毁的对象使用 ObjectPool
  - [ ] 懒初始化: 不必要的资源延迟加载
  - [ ] 及时释放: 完成使用后显式释放资源 (close/dispose)
  - [ ] 监测内存泄漏: 定期检查堆快照

- **算法选择**
  - [ ] 任务分配: O(n log n) 排序，避免 O(n²) 匹配
  - [ ] 查询: O(1) 或 O(log n)，避免 O(n) 扫描
  - [ ] 路径计算: 不在主循环中 (预计算或异步)

- **监测与分析**
  - [ ] 集成性能分析工具 (JProfiler / YourKit)
  - [ ] 定期运行性能基准 (每个 sprint)
  - [ ] 记录性能指标到日志，支持事后分析
  - [ ] 异常性能自动告警 (> 20% 偏差)

#### 检查清单
- [ ] 基准测试通过 (帧率、延迟、内存)
- [ ] 无明显的 GC 暂停
- [ ] 50+ 弟子场景平稳运行
- [ ] 内存占用稳定 (无渐进式泄漏)
- [ ] 性能分析报告生成

---

## 2. 技术栈一致性

### 2.1 必需依赖

| 组件 | 版本 | 原因 |
|------|------|------|
| Kotlin | 1.9.x+ | 主要开发语言 |
| JDK | 17+ | 支持现代 Java 特性 |
| Gradle | 8.0+ | 构建工具，支持 KMP |
| Compose Multiplatform | 1.5.x+ | UI 框架 |
| JUnit 5 | 5.9.x+ | 测试框架 |
| MockK | 1.13.x+ | Mocking 框架 |
| lko-ecs4 | local | 自定义 ECS 框架 |
| lko-di | local | 依赖注入框架 |

### 2.2 禁用的技术

- ❌ 继承继承链 (> 2 层) → 改用组合
- ❌ 全局状态 → 改用 DI 容器
- ❌ 反射 (性能关键路径) → 改用编译时代码生成
- ❌ synchronized 关键字 (单线程模型) → 改用 actor 或信号量

---

## 3. 工作流程与检查点

### 3.1 开发工作流程

1. **需求分析** → 生成 task
2. **设计** → 创建必要的组件和系统类骨架
3. **TDD** → 先写测试，后写实现
4. **代码审查** → 至少 1 个 reviewer，检查代码质量和测试
5. **集成测试** → 验证多个模块协作
6. **性能测试** → 确保性能目标达成
7. **合并** → CI/CD 通过后合并到主分支

### 3.2 质量门槛

| 检查项 | 阈值 | 失败后果 |
|-------|------|--------|
| 编译 | 0 error | ❌ 阻止合并 |
| 单元测试 | 100% pass | ❌ 阻止合并 |
| 覆盖率 | ≥ 75% | ⚠ 需要审查 |
| 代码风格 | 100% pass (ktlint) | ⚠ 自动修复 + 审查 |
| 集成测试 | 100% pass | ❌ 阻止合并 |
| 性能基准 | ≤ 10% 下降 | ⚠ 审查 + 优化计划 |

---

## 4. 修订与更新

### 4.1 修订记录

| 版本 | 日期 | 变更 |
|------|------|------|
| 1.0.0 | 2025-12-13 | 初始版本 |

### 4.2 修订流程

- 新规则/原则提交 PR 前需要团队讨论
- 修订后更新版本号并记录变更
- 对所有进行中的 feature 进行回溯检查

---

## 5. 参考与扩展

- **Kotlin 编码规范**: https://kotlinlang.org/docs/coding-conventions.html
- **项目 ECS 框架**: `lko-libs/lko-ecs4`
- **性能优化指南**: `docs/PERFORMANCE.md` (待建)
- **UI 设计规范**: `docs/UI_DESIGN.md` (待建)

---

## 检查清单: 项目团队验收

- [ ] 所有原则已阅读并理解
- [ ] 开发团队同意遵循规则
- [ ] CI/CD 已配置检查点
- [ ] 工具链已整合 (ktlint, JaCoCo, JUnit 等)
- [ ] 团队成员已完成培训
- [ ] 首个版本发布前再次确认

